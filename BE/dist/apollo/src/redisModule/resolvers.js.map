{"version":3,"file":"resolvers.js","sourceRoot":"","sources":["../../../../apollo/src/redisModule/resolvers.ts"],"names":[],"mappings":";;AAAA,sCAA+B;AAC/B,6EAA0D;AAE1D,MAAM,KAAK,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AAEjC,4BAA4B;AAC5B,MAAM,OAAO,GAAG;IACd,IAAI,EAAE,gBAAM,CAAC,SAAS;IACtB,IAAI,EAAE,IAAI;IACV,cAAc,EAAE,OAAO,CAAC,EAAE;QACxB,kBAAkB;QAClB,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,GAAG,GAAG,EAAE,IAAI,CAAC,CAAC;IAC/C,CAAC;CACF,CAAC;AAEF,2BAA2B;AAC3B,MAAM,MAAM,GAAG,IAAI,yCAAW,CAAC;IAC7B,UAAU,EAAE,OAAO;CACpB,CAAC,CAAC;AAEH,qEAAqE;AACrE,IAAI,aAAa,GAAG,CAAC,CAAC;AACtB,MAAM,QAAQ,GAAG,EAAE,CAAC;AACpB,MAAM,OAAO,GAAG,cAAc,CAAC;AAE/B,4DAA4D;AAC5D,2EAA2E;AAC3E,MAAM,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,OAAO,EAAE,EAAE;IACpC,OAAO,CAAC,GAAG,CAAC,mCAAmC,OAAO,EAAE,CAAC,CAAC;IAE1D,8CAA8C;IAC9C,IAAI;QACF,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,iCAAiC;QACnE,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,sCAAsC;QAC9D,OAAO,CAAC,GAAG,CAAC,2BAA2B,CAAC,CAAC;KAC1C;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,CAAC,KAAK,CAAC,kDAAkD,CAAC,CAAC;QAClE,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;KAC9B;AACH,CAAC,CAAC,CAAC;AAEH,WAAW;AACX,MAAM,SAAS,GAAG;IAChB,KAAK,EAAE;QACL,QAAQ,CAAC,IAAI,EAAE,EAAE,EAAE,OAAO;YACxB,OAAO,QAAQ,CAAC;QAClB,CAAC;KACF;IACD,QAAQ,EAAE;QACR,UAAU,EAAE,CAAC,IAAI,EAAE,EAAE,OAAO,EAAE,EAAE,EAAE;YAChC,OAAO,CAAC,GAAG,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC;YACzB,MAAM,UAAU,GAAG,EAAE,EAAE,EAAE,MAAM,CAAC,aAAa,EAAE,CAAC,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC;YACrE,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,YAAY,EAAE,UAAU,EAAE,CAAC,CAAC;YACtD,OAAO,QAAQ,CAAC;QAClB,CAAC;KACF;IACD,YAAY,EAAE;QAEZ,YAAY,EAAE;YACZ,0BAA0B;YAC1B,0BAA0B;YAC1B,gBAAgB;YAChB,gBAAgB;YAChB,oBAAoB;YACpB,wBAAwB;YACxB,UAAU;YACV,KAAK;YACL,SAAS,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,OAAO,CAAC;SAC/C;KACF;CACF,CAAC;AAEF,kBAAe,SAAS,CAAC","sourcesContent":["import Config from '../config';\r\nimport { RedisPubSub } from 'graphql-redis-subscriptions';\r\n\r\nconst Redis = require('ioredis');\r\n\r\n// Instantiate Redis clients\r\nconst options = {\r\n  host: Config.redisHost,\r\n  port: 6379,\r\n  retry_strategy: options => {\r\n    // reconnect after\r\n    return Math.max(options.attempt * 100, 3000);\r\n  }\r\n};\r\n\r\n// Instantiate Redis PubSub\r\nconst pubsub = new RedisPubSub({\r\n  connection: options\r\n});\r\n\r\n// Test in-memory database (you would use some real DB in production)\r\nlet nextMessageId = 1;\r\nconst messages = [];\r\nconst CHANNEL = `messageAdded`;\r\n\r\n// Update 'database' on new messages (not just on mutations)\r\n// This allows us to update db when messages come into Redis from elsewhere\r\npubsub.subscribe(CHANNEL, (payload) => {\r\n  console.log(`New message received on channel ${CHANNEL}`);\r\n\r\n  // extract message object from payload wrapper\r\n  try {\r\n    const message = payload[CHANNEL]; // object wrapped in channel name\r\n    messages.push(message); // store in in-memory 'database' above\r\n    console.log(`Added message to database`);\r\n  } catch (error) {\r\n    console.error(`Error trying to extract new message from payload`);\r\n    console.error(error.message);\r\n  }\r\n});\r\n\r\n// Resolver\r\nconst resolvers = {\r\n  Query: {\r\n    messages(root, {}, context) {\r\n      return messages;\r\n    }\r\n  },\r\n  Mutation: {\r\n    addMessage: (root, { message }) => {\r\n      console.log({ message });\r\n      const newMessage = { id: String(nextMessageId++), content: message };\r\n      pubsub.publish(CHANNEL, { messageAdded: newMessage });\r\n      return messages;\r\n    }\r\n  },\r\n  Subscription: {\r\n\r\n    messageAdded: {\r\n      // resolve: (payload) => {\r\n      //   console.log(payload);\r\n      //   return \"pa\"\r\n      //   // return {\r\n      //   //   id: 'sdf',\r\n      //   //   content: 'SDf'\r\n      //   // };\r\n      // },\r\n      subscribe: () => pubsub.asyncIterator(CHANNEL)\r\n    }\r\n  }\r\n};\r\n\r\nexport default resolvers;"]}